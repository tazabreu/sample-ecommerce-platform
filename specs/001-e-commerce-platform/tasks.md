# Tasks: E-Commerce Platform with Catalog, Shopping Cart, and Order Management

**Input**: Design documents from `/specs/001-e-commerce-platform/`  
**Prerequisites**: plan.md, research.md, data-model.md, contracts/, quickstart.md  
**Architecture**: Two microservices (customer-facing-service, order-management-service) with Kafka event-driven communication  
**Tech Stack**: Java 21, Spring Boot 3.x, PostgreSQL, Redis, Kafka (Redpanda locally)

## Execution Flow Summary
This tasks file was generated by analyzing:
1. Implementation plan (plan.md) - Tech stack: Java 21, Spring Boot 3.x, Maven, PostgreSQL, Redis, Kafka
2. Data model (data-model.md) - 7 entities across 2 services
3. API contracts (contracts/) - 15 customer service endpoints + 5 order service endpoints
4. Event schemas (kafka-events.md) - 2 Kafka events (OrderCreated, PaymentCompleted)
5. User journeys (quickstart.md) - Complete checkout flow and manager operations

Tasks are ordered by dependencies following TDD principles:
- Setup → Tests → Models → Services → Controllers → Integration → Polish
- Tests are written first and MUST FAIL before implementation
- Tasks marked [P] can be executed in parallel (different files, no dependencies)

---

## Phase 3.1: Infrastructure Setup (Priority 1)

**Purpose**: Bootstrap project structure, dependencies, and infrastructure before any code

- [X] **T001** Create parent POM with multi-module Maven project structure  
  **Files**: `pom.xml` (root), `customer-facing-service/pom.xml`, `order-management-service/pom.xml`  
  **Details**: Parent POM with dependency management (Spring Boot 3.x, Resilience4j, Testcontainers, REST Assured). Modules: customer-facing-service, order-management-service, shared-lib (optional)

- [X] **T002** [P] Create Docker Compose infrastructure file  
  **Files**: `infrastructure/docker-compose.yml`, `infrastructure/docker-compose.override.yml`  
  **Details**: PostgreSQL 15 (2 databases: customer_db, order_db), Redis 7, Redpanda (Kafka-compatible). Include health checks, volumes, and environment variables

- [X] **T003** [P] Configure Flyway database migrations for customer-facing service  
  **Files**: `customer-facing-service/src/main/resources/db/migration/V1__create_categories_table.sql`, `V2__create_products_table.sql`, `V3__create_carts_table.sql`, `V4__create_cart_items_table.sql`, `V5__create_indexes.sql`  
  **Details**: Create tables per data-model.md with constraints, indexes, and audit fields. Use UUID primary keys, foreign keys, CHECK constraints

- [X] **T004** [P] Configure Flyway database migrations for order management service  
  **Files**: `order-management-service/src/main/resources/db/migration/V1__create_order_enums.sql`, `V2__create_orders_table.sql`, `V3__create_order_items_table.sql`, `V4__create_payment_transactions_table.sql`, `V5__create_indexes.sql`, `V6__create_processed_events_table.sql`  
  **Details**: Create ENUM types (order_status, payment_status), tables with JSONB for addresses, idempotency table

- [X] **T005** [P] Create Kafka topic configuration script  
  **Files**: `infrastructure/kafka/create-topics.sh`  
  **Details**: Create topics `orders.created` and `payments.completed` with 3 partitions, retention 7 days, compression snappy. Include DLQ topics

- [X] **T006** [P] Configure customer-facing service application properties  
  **Files**: `customer-facing-service/src/main/resources/application.yml`, `application-dev.yml`, `application-test.yml`  
  **Details**: Spring Boot config (server port 8080), PostgreSQL connection, Redis connection, Kafka producer, Actuator endpoints, logging (JSON format with correlation IDs)

- [X] **T007** [P] Configure order management service application properties  
  **Files**: `order-management-service/src/main/resources/application.yml`, `application-dev.yml`, `application-test.yml`  
  **Details**: Spring Boot config (server port 8081), PostgreSQL connection, Kafka consumer (group: order-service-group, earliest offset), Actuator, Resilience4j circuit breaker for payment service

- [X] **T008** [P] Configure Resilience4j patterns in customer-facing service  
  **Files**: `customer-facing-service/src/main/java/com/ecommerce/customer/config/ResilienceConfig.java`  
  **Details**: Circuit breaker config for Kafka publishing, timeout policies (500ms for catalog queries), retry with exponential backoff

- [X] **T009** [P] Configure Resilience4j patterns in order management service  
  **Files**: `order-management-service/src/main/java/com/ecommerce/order/config/ResilienceConfig.java`  
  **Details**: Circuit breaker for payment service (3 failures → open, 30s wait), retry policy (3 attempts, 1s-5s backoff), timeout 5s

- [X] **T010** [P] Setup Micrometer and Prometheus metrics exposure  
  **Files**: Customer and order services - `config/MetricsConfig.java`  
  **Details**: Enable `/actuator/prometheus` endpoint, custom metrics (orders created, payment success rate, cart conversions), RED method metrics (Rate, Errors, Duration)

- [X] **T011** [P] Configure Spring Boot Actuator health checks  
  **Files**: Both services - `config/ActuatorConfig.java`  
  **Details**: Health endpoints (`/actuator/health`, `/actuator/health/liveness`, `/actuator/health/readiness`), database health indicator, Kafka health indicator, Redis health indicator

- [X] **T012** [P] Setup structured logging with correlation IDs  
  **Files**: Both services - `src/main/resources/logback-spring.xml`, `config/LoggingConfig.java`  
  **Details**: JSON log format, MDC for correlation IDs (generated at controller entry), log levels (ERROR, WARN, INFO), mask PII in logs

---

## Phase 3.2: Contract Tests First (Priority 2) ⚠️ TDD GATE

**CRITICAL**: These tests MUST be written and MUST FAIL before Phase 3.3 implementation

### Customer-Facing Service Contract Tests

- [X] **T013** [P] Contract test for Category endpoints  
  **Files**: `customer-facing-service/src/test/java/com/ecommerce/customer/contract/CategoryContractTest.java`  
  **Details**: REST Assured tests for GET /api/v1/categories (list), POST /api/v1/categories (create with auth), GET /api/v1/categories/{id}, PUT /api/v1/categories/{id} (update with auth), DELETE /api/v1/categories/{id} (delete with auth). Validate request/response schemas per OpenAPI spec

- [X] **T014** [P] Contract test for Product endpoints  
  **Files**: `customer-facing-service/src/test/java/com/ecommerce/customer/contract/ProductContractTest.java`  
  **Details**: REST Assured tests for GET /api/v1/products (list with pagination and filters), POST /api/v1/products (create with auth), GET /api/v1/products/{id}, PUT /api/v1/products/{id} (update with auth), DELETE /api/v1/products/{id} (delete with auth). Test SKU uniqueness constraint

- [X] **T015** [P] Contract test for Cart endpoints  
  **Files**: `customer-facing-service/src/test/java/com/ecommerce/customer/contract/CartContractTest.java`  
  **Details**: REST Assured tests for GET /api/v1/carts/{sessionId}, DELETE /api/v1/carts/{sessionId}, POST /api/v1/carts/{sessionId}/items (add item), PUT /api/v1/carts/{sessionId}/items/{cartItemId} (update quantity), DELETE /api/v1/carts/{sessionId}/items/{cartItemId}. Verify subtotal calculations

- [X] **T016** [P] Contract test for Checkout endpoint  
  **Files**: `customer-facing-service/src/test/java/com/ecommerce/customer/contract/CheckoutContractTest.java`  
  **Details**: REST Assured test for POST /api/v1/checkout. Validate CustomerInfo schema (name, email, phone, shippingAddress), verify CheckoutResponse schema (orderNumber, status, message)

### Order Management Service Contract Tests

- [X] **T017** [P] Contract test for Order endpoints  
  **Files**: `order-management-service/src/test/java/com/ecommerce/order/contract/OrderContractTest.java`  
  **Details**: REST Assured tests for GET /api/v1/orders/{orderNumber} (guest lookup), GET /api/v1/orders (manager list with filters), POST /api/v1/orders/{orderNumber}/cancel (manager cancel), POST /api/v1/orders/{orderNumber}/fulfill (manager fulfill). Test order status enum validation

- [X] **T018** [P] Contract test for Health endpoints  
  **Files**: `order-management-service/src/test/java/com/ecommerce/order/contract/HealthContractTest.java`  
  **Details**: REST Assured tests for GET /actuator/health, GET /actuator/health/liveness, GET /actuator/health/readiness. Validate HealthResponse schema with components (db, kafka)

### Kafka Event Contract Tests

- [X] **T019** [P] Contract test for OrderCreatedEvent schema  
  **Files**: `customer-facing-service/src/test/java/com/ecommerce/customer/contract/OrderCreatedEventContractTest.java`  
  **Details**: Serialize OrderCreatedEvent to JSON and validate against JSON Schema. Test required fields (eventId, orderId, orderNumber, customer, items, subtotal), test field formats (UUID, ISO 8601 dates, order number pattern)

- [X] **T020** [P] Contract test for PaymentCompletedEvent schema  
  **Files**: `order-management-service/src/test/java/com/ecommerce/order/contract/PaymentCompletedEventContractTest.java`  
  **Details**: Serialize PaymentCompletedEvent to JSON for success and failure cases. Validate status enum (SUCCESS, FAILED), test conditional fields (externalTransactionId present on success, failureReason present on failure)

---

## Phase 3.3: Entity Models & Repositories (Priority 3)

**Dependencies**: Phase 3.2 contract tests must be failing before implementing

### Customer-Facing Service Entities

- [X] **T021** [P] Implement Category entity with validation  
  **Files**: `customer-facing-service/src/main/java/com/ecommerce/customer/model/Category.java`  
  **Details**: JPA entity with @Entity, @Table, UUID id (via @GeneratedValue), name (unique, @NotNull, @Size(max=100)), description (@Size(max=1000)), audit fields (createdAt, updatedAt via @CreationTimestamp, @UpdateTimestamp). One-to-Many relationship to Product

- [X] **T022** [P] Implement Product entity with optimistic locking  
  **Files**: `customer-facing-service/src/main/java/com/ecommerce/customer/model/Product.java`  
  **Details**: JPA entity with UUID id, sku (unique, @Pattern for alphanumeric), name (@NotNull, @Size(max=200)), description, price (@DecimalMin("0.01"), BigDecimal), inventoryQuantity (@Min(0)), categoryId (Many-to-One to Category), isActive (default true), @Version for optimistic locking, audit fields

- [X] **T023** [P] Implement Cart entity  
  **Files**: `customer-facing-service/src/main/java/com/ecommerce/customer/model/Cart.java`  
  **Details**: JPA entity with UUID id, sessionId (unique, @NotNull, @Size(max=100)), subtotal (BigDecimal, calculated), One-to-Many to CartItem (cascade ALL, orphanRemoval true), audit fields, expiresAt (session TTL). Business method: calculateSubtotal()

- [X] **T024** [P] Implement CartItem entity  
  **Files**: `customer-facing-service/src/main/java/com/ecommerce/customer/model/CartItem.java`  
  **Details**: JPA entity with UUID id, Many-to-One to Cart, Many-to-One to Product, quantity (@Min(1)), priceSnapshot (BigDecimal, captured at add time), subtotal (calculated), audit fields, unique constraint on (cartId, productId)

### Order Management Service Entities

- [X] **T025** [P] Implement Order entity with state machine  
  **Files**: `order-management-service/src/main/java/com/ecommerce/order/model/Order.java`  
  **Details**: JPA entity with UUID id, orderNumber (unique, pattern ORD-YYYYMMDD-NNN), customerName, customerEmail, customerPhone, shippingAddress (JSONB via @Type(JsonBinaryType.class)), subtotal (BigDecimal), status (@Enumerated OrderStatus: PENDING/PROCESSING/PAID/FULFILLED/CANCELLED/FAILED), One-to-Many to OrderItem, One-to-One to PaymentTransaction, audit fields. Business methods: canBeCancelled(), markAsPaid(), markAsFailed()

- [X] **T026** [P] Implement OrderItem entity (immutable)  
  **Files**: `order-management-service/src/main/java/com/ecommerce/order/model/OrderItem.java`  
  **Details**: JPA entity with UUID id, Many-to-One to Order, productId (UUID, no FK for historical integrity), productSku, productName, quantity (@Min(1)), priceSnapshot (BigDecimal), subtotal (calculated), createdAt only (immutable after creation)

- [X] **T027** [P] Implement PaymentTransaction entity  
  **Files**: `order-management-service/src/main/java/com/ecommerce/order/model/PaymentTransaction.java`  
  **Details**: JPA entity with UUID id, One-to-One to Order (unique constraint), amount (BigDecimal), status (@Enumerated PaymentStatus: PENDING/SUCCESS/FAILED), paymentMethod (String: MOCK/STRIPE), externalTransactionId (nullable), failureReason (nullable, TEXT), attemptCount (@Min(1)), audit fields. Business methods: markAsSuccessful(), markAsFailed()

### Repositories

- [X] **T028** [P] Implement JPA repositories for customer-facing service  
  **Files**: `customer-facing-service/src/main/java/com/ecommerce/customer/repository/CategoryRepository.java`, `ProductRepository.java`, `CartRepository.java`, `CartItemRepository.java`  
  **Details**: Extend JpaRepository<Entity, UUID>. Custom queries: ProductRepository.findByCategoryIdAndIsActive(), CartRepository.findBySessionId(), CartRepository.deleteByExpiresAtBefore() (cleanup job)

- [X] **T029** [P] Implement JPA repositories for order management service  
  **Files**: `order-management-service/src/main/java/com/ecommerce/order/repository/OrderRepository.java`, `OrderItemRepository.java`, `PaymentTransactionRepository.java`, `ProcessedEventRepository.java`  
  **Details**: Extend JpaRepository. Custom queries: OrderRepository.findByOrderNumber(), OrderRepository.findByStatusAndCreatedAtBetween(), ProcessedEventRepository.existsByEventId() (idempotency check)

---

## Phase 3.4: DTOs & Mappers (Priority 4)

**Dependencies**: Entities (T021-T027) must exist

- [X] **T030** [P] Implement DTOs for customer-facing service  
  **Files**: `customer-facing-service/src/main/java/com/ecommerce/customer/dto/` - CategoryDto, CreateCategoryRequest, UpdateCategoryRequest, ProductDto, CreateProductRequest, UpdateProductRequest, CartDto, CartItemDto, AddCartItemRequest, UpdateCartItemRequest, CheckoutRequest, CustomerInfoDto, ShippingAddressDto, CheckoutResponse  
  **Details**: Match OpenAPI schema exactly. Use Bean Validation annotations (@NotNull, @Size, @Pattern, @Email, @DecimalMin). Include builder pattern for readability

- [X] **T031** [P] Implement DTOs for order management service  
  **Files**: `order-management-service/src/main/java/com/ecommerce/order/dto/` - OrderDto, OrderItemDto, CustomerInfoDto, ShippingAddressDto, CancelOrderRequest, FulfillOrderRequest, HealthResponseDto  
  **Details**: Match OpenAPI schema. Include enums (OrderStatus, PaymentStatus)

- [X] **T032** [P] Configure MapStruct mappers for customer-facing service  
  **Files**: `customer-facing-service/src/main/java/com/ecommerce/customer/mapper/CategoryMapper.java`, `ProductMapper.java`, `CartMapper.java`  
  **Details**: @Mapper(componentModel = "spring") for entity ↔ DTO conversion. Custom mapping for subtotal calculations, price snapshots

- [X] **T033** [P] Configure MapStruct mappers for order management service  
  **Files**: `order-management-service/src/main/java/com/ecommerce/order/mapper/OrderMapper.java`  
  **Details**: @Mapper for Order ↔ OrderDto, handle JSONB address conversion

---

## Phase 3.5: Service Layer (Priority 5)

**Dependencies**: Repositories (T028-T029), DTOs (T030-T033) must exist

### Customer-Facing Service Services

- [X] **T034** Implement CatalogService for category operations  
  **Files**: `customer-facing-service/src/main/java/com/ecommerce/customer/service/CatalogService.java`  
  **Details**: @Service with @Transactional methods: createCategory(), updateCategory(), deleteCategory() (check for products first), listCategories(), getCategoryById(). Throw ResourceNotFoundException if not found

- [X] **T035** Implement CatalogService for product operations  
  **Files**: `customer-facing-service/src/main/java/com/ecommerce/customer/service/CatalogService.java` (extend existing)  
  **Details**: Add methods: createProduct() (validate category exists, check SKU unique), updateProduct() (handle optimistic locking), deleteProduct() (soft delete via isActive=false), listProducts() (with filters and pagination), getProductById()

- [X] **T036** Implement CartService with Redis integration  
  **Files**: `customer-facing-service/src/main/java/com/ecommerce/customer/service/CartService.java`, `config/RedisConfig.java`  
  **Details**: @Service with RedisTemplate<String, Cart> for primary storage. Methods: getCart() (load from Redis or PostgreSQL), addItemToCart() (check product exists, validate inventory, capture price snapshot, update subtotal), updateCartItemQuantity() (validate inventory), removeCartItem(), clearCart(). Sync to PostgreSQL for analytics

- [X] **T037** Implement CheckoutService with inventory decrement  
  **Files**: `customer-facing-service/src/main/java/com/ecommerce/customer/service/CheckoutService.java`  
  **Details**: @Service @Transactional. Method: checkout(sessionId, CustomerInfo) → generates orderNumber (format ORD-YYYYMMDD-###), validates cart not empty, decrements inventory (with pessimistic locking: @Lock(PESSIMISTIC_WRITE)), publishes OrderCreatedEvent to Kafka, clears cart, returns CheckoutResponse. Handle insufficient inventory exception

### Order Management Service Services

- [X] **T038** Implement OrderProcessingService (Kafka consumer)  
  **Files**: `order-management-service/src/main/java/com/ecommerce/order/service/OrderProcessingService.java`  
  **Details**: @Service. Method: processOrderCreatedEvent(OrderCreatedEvent) with @Transactional. Check idempotency (ProcessedEventRepository.existsByEventId()), create Order entity (status=PENDING), create OrderItem entities (bulk insert), create PaymentTransaction (status=PENDING), record eventId in processed_events table, trigger payment processing asynchronously

- [X] **T039** Implement PaymentService with mock implementation  
  **Files**: `order-management-service/src/main/java/com/ecommerce/order/payment/PaymentService.java`, `payment/MockPaymentService.java`, `payment/PaymentResult.java`  
  **Details**: Interface PaymentService.processPayment(PaymentRequest) → PaymentResult. MockPaymentService always returns success with mock transaction ID. Wrap with @CircuitBreaker("paymentService"). Future: StripePaymentService implementation

- [X] **T040** Implement PaymentCompletedService (event publisher/consumer)  
  **Files**: `order-management-service/src/main/java/com/ecommerce/order/service/PaymentCompletedService.java`  
  **Details**: @Service. Methods: publishPaymentCompleted(PaymentCompletedEvent) → send to Kafka, processPaymentCompletedEvent(PaymentCompletedEvent) with @Transactional → update PaymentTransaction status, update Order status (PROCESSING → PAID or FAILED), record eventId for idempotency

- [X] **T041** Implement OrderQueryService for lookups  
  **Files**: `order-management-service/src/main/java/com/ecommerce/order/service/OrderQueryService.java`  
  **Details**: @Service @Transactional(readOnly=true). Methods: getOrderByNumber(), listOrders() (with filters: status, customerEmail, date range, pagination), cancelOrder() (validate status=PENDING/PROCESSING, update to CANCELLED), fulfillOrder() (validate status=PAID, update to FULFILLED, record tracking info)

---

## Phase 3.6: Event Infrastructure (Priority 6)

**Dependencies**: Service layer (T034-T041) must exist

- [X] **T042** [P] Implement Kafka event publisher in customer-facing service  
  **Files**: `customer-facing-service/src/main/java/com/ecommerce/customer/event/OrderCreatedEventPublisher.java`, `event/OrderCreatedEvent.java`, `config/KafkaProducerConfig.java`  
  **Details**: @Component with KafkaTemplate<String, OrderCreatedEvent>. Method: publishOrderCreated(Order, Cart, CustomerInfo) → construct event with correlation ID from MDC, partition key = orderId, send to "orders.created" topic. Configure idempotent producer (acks=all, enable.idempotence=true)

- [X] **T043** [P] Implement Kafka event consumer in order management service  
  **Files**: `order-management-service/src/main/java/com/ecommerce/order/service/OrderProcessingService.java`, `event/OrderCreatedEvent.java`, `config/KafkaConsumerConfig.java`  
  **Details**: @Component with @KafkaListener(topics="orders.created", groupId="order-service-group"). Method: onOrderCreated(ConsumerRecord<String, OrderCreatedEvent>) → extract correlation ID to MDC, call OrderProcessingService.processOrderCreatedEvent(), manual ack. Configure manual commit (enable-auto-commit=false)

- [X] **T044** [P] Implement PaymentCompletedEvent publisher/consumer  
  **Files**: `order-management-service/src/main/java/com/ecommerce/order/service/PaymentCompletedService.java`, `event/PaymentCompletedEvent.java`  
  **Details**: Publisher sends to "payments.completed" topic after payment processing. Consumer listens to same topic, calls PaymentCompletedService.processPaymentCompletedEvent() to update order/payment status

---

## Phase 3.7: REST Controllers (Priority 7)

**Dependencies**: Services (T034-T041) must exist, contract tests (T013-T016) still failing

### Customer-Facing Service Controllers

- [X] **T045** [P] Implement CategoryController with Spring Security  
  **Files**: `customer-facing-service/src/main/java/com/ecommerce/customer/controller/CategoryController.java`  
  **Details**: @RestController @RequestMapping("/api/v1/categories"). Endpoints: GET / (public), POST / (@PreAuthorize("hasRole('MANAGER')")), GET /{id} (public), PUT /{id} (manager), DELETE /{id} (manager). Use @Valid for request bodies, ResponseEntity for proper status codes (201 for create, 204 for delete)

- [X] **T046** [P] Implement ProductController with pagination  
  **Files**: `customer-facing-service/src/main/java/com/ecommerce/customer/controller/ProductController.java`  
  **Details**: @RestController @RequestMapping("/api/v1/products"). Endpoints: GET / (public, with filters: categoryId, isActive, pagination), POST / (manager), GET /{id} (public), PUT /{id} (manager), DELETE /{id} (manager). Return Page<ProductDto> for list

- [X] **T047** [P] Implement CartController with session handling  
  **Files**: `customer-facing-service/src/main/java/com/ecommerce/customer/controller/CartController.java`  
  **Details**: @RestController @RequestMapping("/api/v1/carts"). Endpoints: GET /{sessionId}, DELETE /{sessionId}, POST /{sessionId}/items, PUT /{sessionId}/items/{cartItemId}, DELETE /{sessionId}/items/{cartItemId}. Return updated CartDto after mutations

- [X] **T048** Implement CheckoutController with validation  
  **Files**: `customer-facing-service/src/main/java/com/ecommerce/customer/controller/CheckoutController.java`  
  **Details**: @RestController @RequestMapping("/api/v1"). Endpoint: POST /checkout with @Valid CheckoutRequest. Call CheckoutService.checkout(), return 201 with CheckoutResponse. Handle InsufficientInventoryException → 409 Conflict

### Order Management Service Controllers

- [X] **T049** [P] Implement OrderController with role-based access  
  **Files**: `order-management-service/src/main/java/com/ecommerce/order/controller/OrderController.java`  
  **Details**: @RestController @RequestMapping("/api/v1/orders"). Endpoints: GET /{orderNumber} (public, guest lookup), GET / (@PreAuthorize("hasRole('MANAGER')"), with filters), POST /{orderNumber}/cancel (manager), POST /{orderNumber}/fulfill (manager). Return OrderDto, handle order not found → 404

### Exception Handling

- [X] **T050** [P] Implement global exception handler for both services  
  **Files**: `customer-facing-service/src/main/java/com/ecommerce/customer/exception/GlobalExceptionHandler.java`, `order-management-service/src/main/java/com/ecommerce/order/exception/GlobalExceptionHandler.java`  
  **Details**: @RestControllerAdvice with @ExceptionHandler methods. Handle: ResourceNotFoundException → 404, IllegalArgumentException → 400, ConstraintViolationException → 400, OptimisticLockException → 409, DataIntegrityViolationException → 409, Exception → 500. Return ErrorResponse DTO matching OpenAPI schema. Log exceptions with correlation IDs

---

## Phase 3.8: Security Configuration (Priority 8)

**Dependencies**: Controllers (T045-T049) must exist

- [X] **T051** Configure Spring Security in customer-facing service  
  **Files**: `customer-facing-service/src/main/java/com/ecommerce/customer/config/SecurityConfig.java`  
  **Details**: @Configuration @EnableWebSecurity. Configure HttpSecurity: permit public endpoints (GET /api/v1/products, /api/v1/categories, /api/v1/carts/**, POST /api/v1/checkout, /actuator/health), require ROLE_MANAGER for POST/PUT/DELETE /api/v1/products and /api/v1/categories. OAuth2 Resource Server with JWT validation (mock JWKS endpoint for local dev)

- [X] **T052** [P] Configure Spring Security in order management service  
  **Files**: `order-management-service/src/main/java/com/ecommerce/order/config/SecurityConfig.java`  
  **Details**: @Configuration @EnableWebSecurity. Permit GET /api/v1/orders/{orderNumber} (guest lookup), require ROLE_MANAGER for GET /api/v1/orders, POST /api/v1/orders/*/cancel, POST /api/v1/orders/*/fulfill. OAuth2 Resource Server with JWT validation

- [X] **T053** [P] Implement mock authentication endpoint for local development  
  **Files**: `customer-facing-service/src/main/java/com/ecommerce/customer/controller/AuthController.java`, `service/MockAuthService.java`  
  **Details**: @RestController @RequestMapping("/api/v1/auth"). POST /login with username/password → generate mock JWT with role claim (ROLE_MANAGER for username="manager"). Only active in dev profile (@Profile("dev"))

---

## Phase 3.9: Data Access Modernization (Priority 9)

**Dependencies**: Security configuration (T051-T053) complete

**Purpose**: Migrate from Spring Data JPA to Spring Data JDBC for improved performance, transparency, and reduced complexity

**Migration Guide**: Refer to `MIGRATION_JPA_JDBC.md` for comprehensive 53-task migration plan with checkpoints, decision points, and code examples. See `MIGRATION_JPA_JDBC_CORRECTIONS.md` for validation against official Spring Data documentation

- [ ] **T054** Migrate customer-facing service from JPA to Spring Data JDBC
  **Files**: All entity classes in `customer-facing-service/src/main/java/com/ecommerce/customer/model/`, all repositories in `customer-facing-service/src/main/java/com/ecommerce/customer/repository/`, `pom.xml`, service layer, tests
  **Scope**: 7 entities (Category, Product, Cart, CartItem, OrderCreatedOutbox, CheckoutIdempotency, OrderNumberSequence)
  **Strategy**: 
  - Phase 1: Test preparation (update tests to fail-first, remove JPA-specific patterns)
  - Phase 2: Entity transformation (replace JPA annotations with JDBC, convert relationships to aggregates)
  - Phase 3: Repository updates (CrudRepository, SQL queries, remove @EntityGraph)
  - Phase 4: Service adjustments (explicit save calls, UUID generation, no lazy loading)
  - Phase 5: Configuration (JdbcConfig, remove Jackson Hibernate module, audit callbacks)
  - Phase 6: Test fixes (all tests passing with JDBC)
  **Key Changes**:
  - Cart → CartItem: Aggregate root with `@MappedCollection(idColumn = "cart_id")`
  - Product: Replace `@ManyToOne Category` with `UUID categoryId`
  - CartItem: Remove back-reference to Cart, store `UUID productId` instead of Product entity
  - Repositories: Replace JPQL with SQL, replace `@Lock(PESSIMISTIC_WRITE)` with `SELECT ... FOR UPDATE`
  - Services: Explicit `save()` after mutations, manual UUID generation, no lazy loading assumptions
  - Redis: Remove Hibernate5JakartaModule from Jackson configuration
  **Checkpoints**: See MIGRATION_JPA_JDBC.md M001-M038 for detailed steps and human review points
  **Acceptance Criteria**: All tests pass, no JPA dependencies in `mvn dependency:tree`, contract tests passing

- [ ] **T055** Migrate order-management service from JPA to Spring Data JDBC
  **Files**: All entity classes in `order-management-service/src/main/java/com/ecommerce/order/model/`, all repositories in `order-management-service/src/main/java/com/ecommerce/order/repository/`, `pom.xml`, service layer, tests
  **Scope**: 4 entities (Order, OrderItem, PaymentTransaction, ProcessedEvent)
  **Strategy**: Same phases as T054 (see MIGRATION_JPA_JDBC.md)
  **Key Changes**:
  - Order → OrderItem: Aggregate root with `@MappedCollection(idColumn = "order_id")`
  - Order.shippingAddress: Custom JSONB converter for `Map<String, String>`
  - PaymentTransaction: **DECISION POINT** - Separate aggregate (recommended) vs. embedded in Order
  - OrderItem: Remove back-reference to Order, immutable after creation
  - ProcessedEvent: Simple entity, minimal changes
  - Repositories: Convert JPQL to SQL with explicit ENUM casting (`CAST(:status AS order_status)`)
  - Services: Explicit save for Order + items, manual UUID generation for nested entities
  **Special Considerations**:
  - JSONB converters for Map serialization (shippingAddress)
  - PostgreSQL ENUM types require explicit casting in SQL queries
  - Kafka event processing: Ensure idempotency checks work with JDBC transactions
  - PaymentTransaction relationship: If separate aggregate, add `UUID orderId` field and fetch via repository
  **Checkpoints**: See MIGRATION_JPA_JDBC.md for PaymentTransaction aggregate boundary decision (M018)
  **Acceptance Criteria**: All tests pass, event processing works correctly, JSONB serialization functional

- [ ] **T056** Performance validation: JPA vs JDBC comparison
  **Files**: `customer-facing-service/src/test/java/com/ecommerce/customer/benchmark/DataAccessBenchmark.java`, `docs/jdbc-performance-analysis.md`
  **Details**: 
  - Create JMH benchmarks comparing: 1) Cart retrieval with items, 2) Checkout flow with inventory updates, 3) Bulk product queries
  - Measure: Query count, memory footprint, latency (p50/p95/p99), throughput
  - Enable SQL logging to capture query patterns: `logging.level.org.springframework.jdbc.core=DEBUG`
  - Run EXPLAIN ANALYZE on critical queries to verify index usage
  - Document results showing: query count comparison, memory footprint changes, latency comparison
  - Include recommendations for optimal aggregate boundaries and potential optimizations (projections, caching)
  - Load test with 100 concurrent users to validate behavior under realistic load
  **Acceptance Criteria**: All benchmarks execute successfully, no N+1 query patterns detected, results documented for future reference

---

## Phase 3.10: Integration Tests (Priority 10)

**Dependencies**: Data access migration (T054-T056) complete, contract tests now passing

- [ ] **T057** [P] Integration test for complete checkout flow
  **Files**: `customer-facing-service/src/test/java/com/ecommerce/customer/integration/CheckoutFlowIntegrationTest.java`
  **Details**: @SpringBootTest with @Testcontainers (PostgreSQL, Redis, Kafka). Scenario: Create category → create product → add to cart → checkout → verify OrderCreatedEvent published to Kafka → verify inventory decremented → verify cart cleared. Use @EmbeddedKafka and KafkaTestConsumer

- [ ] **T058** [P] Integration test for order processing flow
  **Files**: `order-management-service/src/test/java/com/ecommerce/order/integration/OrderProcessingIntegrationTest.java`
  **Details**: @SpringBootTest with @Testcontainers (PostgreSQL, Kafka). Scenario: Publish OrderCreatedEvent → verify order created with status=PENDING → verify payment processing triggered → verify PaymentCompletedEvent published → verify order status=PAID → verify payment transaction updated

- [ ] **T059** [P] Integration test for idempotency handling
  **Files**: `order-management-service/src/test/java/com/ecommerce/order/integration/IdempotencyIntegrationTest.java`
  **Details**: Publish same OrderCreatedEvent twice (duplicate eventId) → verify only one order created, second event logged and skipped

- [ ] **T060** [P] Integration test for cart expiration
  **Files**: `customer-facing-service/src/test/java/com/ecommerce/customer/integration/CartExpirationIntegrationTest.java`
  **Details**: Create cart with short TTL in Redis → wait for expiration → verify cart not accessible → verify cleanup job removes from PostgreSQL

- [ ] **T061** [P] Integration test for payment failure handling
  **Files**: `order-management-service/src/test/java/com/ecommerce/order/integration/PaymentFailureIntegrationTest.java`
  **Details**: Configure MockPaymentService to fail → publish OrderCreatedEvent → verify order status=FAILED → verify PaymentCompletedEvent with status=FAILED and failureReason populated

- [ ] **T062** [P] Integration test for circuit breaker behavior
  **Files**: `order-management-service/src/test/java/com/ecommerce/order/integration/CircuitBreakerIntegrationTest.java`
  **Details**: Configure payment service to timeout → trigger 3 payment attempts → verify circuit breaker opens → verify health check reports circuit breaker OPEN → wait for timeout → verify circuit breaker transitions to HALF_OPEN

- [ ] **T063** [P] Integration test for manager operations
  **Files**: `order-management-service/src/test/java/com/ecommerce/order/integration/ManagerOperationsIntegrationTest.java`
  **Details**: Create paid order → test cancel order (validate status change to CANCELLED) → create another paid order → test fulfill order (validate status=FULFILLED, tracking info recorded)

---

## Phase 3.11: Deployment & Infrastructure (Priority 11)

**Dependencies**: All integration tests (T057-T063) passing

- [x] **T064** [P] Create optimized Dockerfiles for both services
  **Files**: `customer-facing-service/Dockerfile`, `order-management-service/Dockerfile`
  **Details**: Multi-stage build with Maven dependency caching, Spring Boot layer extraction, security hardening with non-root user, HEALTHCHECK, JVM tuning for containers

- [ ] **T065** [P] Create environment variable template
  **Files**: `.env.example`
  **Details**: Template for DATABASE_URL, DATABASE_USERNAME, DATABASE_PASSWORD, REDIS_URL, KAFKA_BOOTSTRAP_SERVERS, JWT_SECRET, JWT_ISSUER. Include comments for local vs cloud values. Maintain sync with actual environment variables used in application.yml

---

## Phase 3.12: Observability & Monitoring (Priority 12)

**Dependencies**: Deployment infrastructure (T064-T065) complete

- [ ] **T066** [P] Implement custom Micrometer metrics for customer-facing service
  **Files**: `customer-facing-service/src/main/java/com/ecommerce/customer/metrics/BusinessMetrics.java`
  **Details**: @Component with MeterRegistry. Custom counters: checkout_attempts_total, checkout_success_total, checkout_failure_total (tag: reason), cart_items_added_total, product_views_total. Custom gauges: active_carts_count

- [ ] **T067** [P] Implement custom Micrometer metrics for order management service
  **Files**: `order-management-service/src/main/java/com/ecommerce/order/metrics/BusinessMetrics.java`
  **Details**: Custom counters: orders_created_total, payments_success_total, payments_failed_total (tag: failureReason), orders_cancelled_total, orders_fulfilled_total. Custom timers: order_processing_duration_seconds (from OrderCreated event to status=PAID)

- [ ] **T068** [P] Configure Prometheus scraping for both services
  **Files**: `infrastructure/prometheus/prometheus.yml`, `infrastructure/prometheus/alert-rules.yml`
  **Details**: Scrape config for /actuator/prometheus endpoints (customer:8080, order:8081). Alert rules: consumer_lag > 1000, payment_success_rate < 0.95, p95_latency > 500ms, service_down

- [ ] **T069** [P] Setup Grafana dashboards
  **Files**: `infrastructure/grafana/dashboards/ecommerce-overview.json`, `order-processing.json`
  **Details**: Overview dashboard: request rate, error rate, p95 latency, active carts, orders per minute. Order processing dashboard: order status distribution, payment success rate, consumer lag, circuit breaker state

---

## Phase 3.13: Documentation & Polish (Priority 13)

**Dependencies**: All implementation and tests complete

- [ ] **T070** [P] Write comprehensive README.md  
  **Files**: `README.md` (root)  
  **Details**: Project overview, architecture diagram (mermaid), prerequisites (Java 21, Maven, Docker), quickstart (docker-compose up, mvn spring-boot:run), API documentation links (Swagger UI), testing instructions (mvn verify), deployment guide (Kubernetes apply), troubleshooting section

- [ ] **T067** [P] AI-driven API documentation sync
  **Files**: `specs/001-e-commerce-platform/contracts/`, AI analysis of code vs specs
  **Details**: Use AI to scan implemented controllers and ensure API contracts in /contracts/ are synchronized with actual code. Update OpenAPI specs if code has evolved beyond initial specs. Maintain drift-free documentation

- [ ] **T068** [P] Write service-specific README files
  **Files**: `customer-facing-service/README.md`, `order-management-service/README.md`
  **Details**: Service-specific architecture, database schema, API endpoints, Kafka topics (producer/consumer), configuration properties, local development setup, testing

- [ ] **T069** [P] Create quickstart validation script
  **Files**: `scripts/validate-quickstart.sh`
  **Details**: Bash script that executes quickstart.md scenarios: start infrastructure → create category → create product → add to cart → checkout → verify order status → cleanup. Exit with error if any step fails

- [ ] **T070** [P] Run SonarQube analysis and fix issues
  **Files**: Apply fixes across codebase
  **Details**: Run `mvn sonar:sonar`, address critical/major issues: code smells, security hotspots, duplications. Target: 0 bugs, 0 vulnerabilities, <5% duplication, >80% coverage

- [ ] **T071** [P] Create operational runbook
  **Files**: `docs/runbook.md`
  **Details**: Runbook for operators: health check URLs, log locations, common issues (Kafka consumer lag → restart consumer, circuit breaker open → check payment service), metric dashboards, alert response procedures

---

## Dependencies Graph

```
Setup (T001-T012)
  ↓
Contract Tests (T013-T020) [MUST FAIL]
  ↓
Entities & Repositories (T021-T029)
  ↓
DTOs & Mappers (T030-T033)
  ↓
Service Layer (T034-T041)
  ↓
Event Infrastructure (T042-T044)
  ↓
Controllers (T045-T050) [Contract tests now PASS]
  ↓
Security (T051-T053)
  ↓
Data Access Modernization (T054-T056) [JPA → JDBC Migration]
  ↓
Integration Tests (T057-T063)
  ↓
Deployment (T064-T065)
  ↓
Observability (T066-T069)
  ↓
Documentation (T070-T078)
  ↓
Reliability Hardening (T079-T086)
```

**Critical Path Dependencies**:
- T003, T004 (migrations) → T021-T027 (entities need tables)
- T021-T027 (entities) → T028-T029 (repositories need entities)
- T028-T029 (repositories) → T034-T041 (services need repositories)
- T034-T041 (services) → T042-T044 (events need services)
- T034-T041 (services) → T045-T049 (controllers need services)
- T013-T020 (contract tests) validate T045-T049 (controllers)
- T045-T049 (controllers) → T054-T056 (JDBC migration)
- T054-T056 (JDBC migration) → T057-T063 (integration tests need full stack)

---

## Parallel Execution Examples

### Setup Phase (All Parallel)
```bash
# All independent infrastructure tasks
Task T002: "Create Docker Compose infrastructure"
Task T003: "Configure Flyway migrations for customer service"
Task T004: "Configure Flyway migrations for order service"
Task T005: "Create Kafka topic configuration"
Task T006: "Configure customer service application.yml"
Task T007: "Configure order service application.yml"
Task T008: "Configure Resilience4j in customer service"
Task T009: "Configure Resilience4j in order service"
Task T010: "Setup Micrometer and Prometheus"
Task T011: "Configure Actuator health checks"
Task T012: "Setup structured logging"
```

### Contract Tests Phase (All Parallel - Different Test Files)
```bash
# All independent test files
Task T013: "Category endpoints contract tests"
Task T014: "Product endpoints contract tests"
Task T015: "Cart endpoints contract tests"
Task T016: "Checkout endpoint contract tests"
Task T017: "Order endpoints contract tests"
Task T018: "Health endpoints contract tests"
Task T019: "OrderCreatedEvent schema contract tests"
Task T020: "PaymentCompletedEvent schema contract tests"
```

### Entity Models Phase (All Parallel - Different Entity Files)
```bash
# All independent entity files
Task T021: "Category entity"
Task T022: "Product entity"
Task T023: "Cart entity"
Task T024: "CartItem entity"
Task T025: "Order entity"
Task T026: "OrderItem entity"
Task T027: "PaymentTransaction entity"
Task T028: "Customer service repositories"
Task T029: "Order service repositories"
```

### Integration Tests Phase (All Parallel - Different Test Files)
```bash
# All independent integration tests
Task T057: "Checkout flow integration test"
Task T058: "Order processing integration test"
Task T059: "Idempotency integration test"
Task T060: "Cart expiration integration test"
Task T061: "Payment failure integration test"
Task T062: "Circuit breaker integration test"
Task T063: "Manager operations integration test"
```

---

## Task Validation Checklist

**Contract Coverage**:
- [x] All 15 customer service endpoints have contract tests (T013-T016)
- [x] All 5 order service endpoints have contract tests (T017-T018)
- [x] All 2 Kafka events have schema contract tests (T019-T020)

**Entity Coverage**:
- [x] All 7 entities have model tasks (T021-T027: Category, Product, Cart, CartItem, Order, OrderItem, PaymentTransaction)
- [x] All entities have corresponding repository tasks (T028-T029)

**TDD Workflow**:
- [x] Contract tests (Phase 3.2) come before implementation (Phase 3.3+)
- [x] Integration tests (Phase 3.9) come after all implementation
- [x] Contract tests explicitly marked as "MUST FAIL" before implementation

**Parallelization**:
- [x] All [P] tasks operate on different files or independent modules
- [x] No [P] tasks have dependencies on each other
- [x] Sequential tasks within same file not marked [P]

**Completeness**:
- [x] All user stories from quickstart.md covered (checkout flow T054, manager operations T060)
- [x] All resilience patterns covered (circuit breaker T059, retry in T008-T009)
- [x] All observability requirements covered (metrics T066-T067, health checks T011, logging T012)
- [x] All security requirements covered (JWT auth T051-T053, role-based access in controllers)

**File Paths**:
- [x] All tasks include exact file paths
- [x] Paths follow plan.md structure (multi-module Maven: customer-facing-service/, order-management-service/)

---

## Notes for Implementation Agents

1. **TDD is Mandatory**: Do not implement T021-T053 until contract tests (T013-T020) are written and failing
2. **Testcontainers**: Integration tests (T054-T060) use Testcontainers for PostgreSQL, Redis, Kafka - ensure Docker is running
3. **Idempotency**: Critical for Kafka consumers (T038, T040) - always check ProcessedEventRepository before processing
4. **Optimistic Locking**: Product entity (T022) uses @Version - handle OptimisticLockException in checkout (T037)
5. **Circuit Breaker**: PaymentService (T039) wrapped with @CircuitBreaker - test open/closed states (T059)
6. **Correlation IDs**: Set in controller filters, propagate to MDC, include in all logs and events
7. **JSON Logging**: Use structured logging (T012) with correlation IDs for traceability across services
8. **Database Migrations**: Flyway migrations (T003-T004) are immutable - never edit V1, create V6 for changes
9. **Environment Parity**: Use same PostgreSQL/Redis/Kafka versions locally (docker-compose.yml T002) and prod (k8s T062-T064)
10. **Health Checks**: Actuator health (T011) reflects circuit breaker state, database connectivity, Kafka consumer status

---

## Success Criteria

**Phase 3.2 (Contract Tests)**: All contract tests written, all failing (expected - no implementation yet)
**Phase 3.7 (Controllers)**: All contract tests now passing, 100% API coverage
**Phase 3.9 (Data Access)**: JPA to JDBC migration complete, all tests passing with new data access layer
**Phase 3.10 (Integration)**: All integration tests passing, end-to-end flows validated
**Phase 3.11 (Deployment)**: Services deployable via `docker-compose up`, accessible via curl
**Phase 3.13 (Documentation)**: Quickstart validation script (T072) executes successfully, API docs synchronized

**Final Validation**:
- [ ] All 91 tasks completed (T001-T086 + T087-T091)
- [ ] Contract tests: 100% passing (20 test files)
- [ ] Integration tests: 100% passing (7 test files)
- [ ] Code coverage: >80% (services and controllers)
- [ ] SonarQube: 0 bugs, 0 vulnerabilities (T073)
- [ ] Quickstart script: Executes without errors (T072)
- [ ] Health checks: All services UP (T011)
- [ ] Metrics: Exposed at /actuator/prometheus (T010)
- [ ] Data access: Spring Data JDBC migration complete (T054-T056)

---

**Tasks Generation Complete**: 91 numbered, dependency-ordered, parallel-marked tasks ready for execution
**Estimated Effort**: 360-460 developer-hours (assuming 4-5 hours per task average)
**Recommended Team Size**: 3-4 developers (pair on critical paths, parallelize independent tasks)
**Timeline**: 8-10 weeks for full implementation with testing, documentation, and JDBC migration

---

## Phase 3.14: Reliability & Operational Hardening (Priority 14)

Dependencies: All core features implemented (T001–T078)

- [ ] **T079** Implement transactional outbox for OrderCreated in customer service
  **Files**: `customer-facing-service/src/main/java/com/ecommerce/customer/outbox/`, migrations `customer-facing-service/src/main/resources/db/migration/V6__create_outbox_table.sql`
  **Details**: Persist outbox record within checkout DB transaction; background publisher relays to Kafka with exactly-once semantics (de-dup by eventId)

- [ ] **T080** Standardize error handling to RFC 7807 Problem Details
  **Files**: `customer-facing-service/src/main/java/com/ecommerce/customer/exception/GlobalExceptionHandler.java`, `order-management-service/src/main/java/com/ecommerce/order/exception/GlobalExceptionHandler.java`
  **Details**: Return `application/problem+json` with `type`, `title`, `status`, `detail`, `instance`; update tests where needed

- [ ] **T081** Add idempotent checkout using Idempotency-Key
  **Files**: `customer-facing-service/src/main/java/com/ecommerce/customer/controller/CheckoutController.java`, idempotency repository, migration `customer-facing-service/src/main/resources/db/migration/V7__create_idempotency_table.sql`
  **Details**: Store key → response hash for 24h; return cached response on replay; guard inventory updates

- [ ] **T082** Replace in-memory order number with DB-backed daily sequence
  **Files**: `customer-facing-service/src/main/java/com/ecommerce/customer/service/CheckoutService.java`, migration `customer-facing-service/src/main/resources/db/migration/V8__create_order_number_sequence.sql`
  **Details**: Generate `ORD-YYYYMMDD-###` from sequence; ensure unique index; concurrent-safe

- [ ] **T083** Add Kafka DLT and retry/backoff policies
  **Files**: `infrastructure/kafka/create-topics.sh`, consumer configs in both services
  **Details**: Create `*.DLT` topics; configure seek-to-current with backoff; route to DLT after max attempts; add metrics

- [ ] **T084** Correlation ID propagation and header standards
  **Files**: HTTP filter in both services, Kafka header mappers
  **Details**: Use `X-Correlation-ID`; enforce generation and propagation to logs/events; document in AGENTS.md

- [ ] **T085** Optional Redis profile and in-memory cart adapter
  **Files**: `customer-facing-service/src/main/java/com/ecommerce/customer/config/RedisConfig.java`, new in-memory adapter
  **Details**: Enable `cart.storage=in-memory|redis`; default to in-memory for tests

- [ ] **T086** Operational runbooks for DLQ replay and idempotency cleanup
  **Files**: `docs/runbook.md` (extend)
  **Details**: Add procedures, commands, metrics to monitor


## Urgent Remediation Tasks (Priority 0)

These items address active drift from the specification and must precede new feature work. Coordinate across agents to honor TDD (write failing tests, implement, then update docs/tasks).

- [ ] **T087** Harden checkout with persisted Idempotency-Key workflow
  **Context**: FR-043 requires 24h deduplication for POST /checkout, but current controller/service paths execute side effects on every request.
  **Files**: `customer-facing-service/src/main/java/com/ecommerce/customer/controller/CheckoutController.java`, `.../service/CheckoutService.java`, new idempotency component under `customer-facing-service/src/main/java/com/ecommerce/customer/idempotency/`, migration `customer-facing-service/src/main/resources/db/migration/V9__checkout_idempotency.sql`, contract/integration tests under `customer-facing-service/src/test/java/com/ecommerce/customer/`.
  **Guidelines**: Enforce `Idempotency-Key` header (400 if missing), persist key → request fingerprint → serialized response with TTL, short-circuit on replays before mutating inventory/event state, and backfill failing-first tests. Ensure cached responses include correlation IDs and align with Problem Details on validation errors.

- [ ] **T088** Implement transactional outbox publishing for OrderCreated events
  **Context**: Checkout currently blocks on synchronous Kafka sends (`CompletableFuture.join()`), breaching the transactional outbox requirement (spec §Technical Conventions, FR-041).
  **Files**: `customer-facing-service/src/main/java/com/ecommerce/customer/service/CheckoutService.java`, new outbox entities/repositories/schedulers under `customer-facing-service/src/main/java/com/ecommerce/customer/outbox/`, migration `customer-facing-service/src/main/resources/db/migration/V10__order_created_outbox.sql`, resiliency tests + runbooks.
  **Guidelines**: Persist order/cart state and outbox row in the same transaction; background publisher streams pending rows, emits to Kafka with idempotent eventId handling, and marks records as sent (or moves to DLQ). Remove synchronous publish, add Testcontainers coverage simulating publish failures and restarts.

- [ ] **T089** Standardize API errors on RFC 7807 Problem Details
  **Context**: Both services emit bespoke error DTOs, conflicting with Operating Principle #5.
  **Files**: `customer-facing-service/src/main/java/com/ecommerce/customer/exception/GlobalExceptionHandler.java`, `order-management-service/src/main/java/com/ecommerce/order/exception/GlobalExceptionHandler.java`, shared helpers in `shared-lib/`, API docs/tests.
  **Guidelines**: Adopt Spring `ProblemDetail`, emit `application/problem+json` with `type`, `title`, `status`, `detail`, `instance`; attach `correlationId` via extensions; update OpenAPI contracts and regression tests to expect the new schema.

- [ ] **T090** Switch logging to structured JSON with correlation propagation
  **Context**: `application.yml` log patterns remain plaintext, violating the structured logging convention.
  **Files**: `customer-facing-service/src/main/resources/application.yml`, `order-management-service/src/main/resources/application.yml`, logging configs, infrastructure notes.
  **Guidelines**: Configure Logback JSON appenders (e.g., logstash encoder) capturing timestamp, level, logger, correlationId, request metadata, and business tags. Validate via integration test or smoke script that log lines are valid JSON and include headers.

- [ ] **T091** Backfill RED/business metrics instrumentation
  **Context**: MetricsConfig only sets common tags; spec calls for counters/gauges (checkout_success_total, orders_created_total, etc.).
  **Files**: `customer-facing-service/src/main/java/com/ecommerce/customer/config/MetricsConfig.java`, `order-management-service/src/main/java/com/ecommerce/order/config/MetricsConfig.java`, services emitting metrics, tests hitting `/actuator/prometheus`.
  **Guidelines**: Instrument critical paths with Micrometer counters for attempts/success/failure (tagged by reason), gauges for active carts and in-flight orders, and timers for checkout/order processing duration. Add assertions ensuring metrics surface via actuator endpoints.

